# Virtual Memory I

*December 15, 2024*

## Virtual Memory Concepts

### Virtual Memory

- 虚拟内存是内存层次结构中的下一层级
	- 为程序提供一个非常大的主存储器的假象
	- 工作集(Working set)以"页面(pages)"为单位存储在主存中，其他内容存储在磁盘上

- 需求分页(Demand paging)
    - 允许运行比主存(DRAM)更大的程序
    - 通过页面置换实现内存管理

- 隐藏不同机器配置之间的差异，使程序可以在不同硬件配置上运行
- 允许操作系统共享内存，**保护**程序互不干扰 
- 每个进程认为自己拥有全部内存空间

### Great Idea #3: Principle of Locality / Memory Hierarchy

![[Memory Hierarchy.png]]

### Address Spaces

地址空间指所有可用内存位置的集合。两种地址类型：

- 虚拟地址空间
    - 用户程序所知道的地址集合
    - 每个进程都可以使用相同的地址范围(如0到0xffffffff)

- 物理地址空间
    - 映射到实际物理内存位置的地址集合
    - 对用户应用程序隐藏
    - 由内存管理器进行虚拟地址到物理地址的转换

### Analogy

- 书名 ≈ 虚拟地址(virtual address)
- 图书馆索书号 ≈ 物理地址(physical address)
- 卡片目录 ≈ 页表(page table)
- 图书在本地图书馆/分馆 ≈ 有效位(valid bit)（在内存中/在磁盘上）
- 图书借阅权限 ≈ 访问权限(access rights)

### Memory Hierarchy Requirements

- 允许多个进程同时占用内存并提供保护
	- 不要让一个程序读/写另一个程序的内存
- 地址空间
	- 给每个程序有非常大的私有内存的假象
	- 每个程序都有不同的内存视图

## Physical Memory and Storage

- Memory(DRAM)
- Stroage - "Disk" 非易失性(Non-volatile)
	- SSD 固态硬盘
		- 像巨大的寄存器文件
		- 快速访问所有位置
		- 读/写块，而不是字节，潜在的可靠性问题
	- HDD 硬盘驱动器
		- 机械转动

寄存器文件和缓存为SRAM

## Memory Manager

在"裸机"系统（不含操作系统）中，加载/存储时发出的地址是真实的物理地址。

- 在这种模式下，任何进程都可以发出任何地址，因此可以访问内存的任何部分，甚至是它不拥有的区域
	- 例如操作系统数据结构
- 我们应该通过操作系统控制的机制发送所有地址，然后再将其发送到 DRAM
	- 检查进程是否拥有访问内存特定部分的权限

多个进程由操作系统管理，操作系统将这些进程复用到可用内核上，但是内存只有一个，我们不能在上下文切换中“保持”其内容。

### Responsibilities of Memory Manager

1. 地址转换
    - 将虚拟地址映射到物理地址
    - 确保不同进程的地址空间隔离

2. 内存保护
    - 隔离不同进程的内存空间
    - 防止用户程序干扰操作系统内存
    - 保护程序不受其他程序错误的影响

3. 内存交换
    - 在内存和磁盘之间交换数据
    - 通过使用磁盘存储创造更大内存的假象
	    - 使用缓存策略优化性能

## Paged Memory

- 物理内存(DRAM)被分成固定大小的页面(pages)
- 典型页面大小：4 KiB 或更大
- 虚拟地址结构（32位示例）：

```
[page number(20-bits)|offset(12-bits)]
```

- 每个进程都有专属的页表
- 页表存储虚拟页号到物理页号的映射
- 物理内存中的页面可以不连续

### Paged Memory Address Translation

1. 操作系统跟踪活动进程
2. 选择正确的页表
3. 内存管理器：
    - 从虚拟地址提取页号（顶部20位）
    - 在页表中查找对应的物理页地址
    - 计算最终物理地址：物理页地址 + 偏移量

### Protection

- 通过页表机制实现进程间内存隔离
- 每个进程只能访问自己的页表项指向的内存
- 页表由操作系统在监督模式(supervisor mode)下管理
- 操作系统可以将同一物理页面分配给多个进程
- 写保护机制：
    - 可以标记某些页面为只读（页表条目中的标志位）
    - 尝试写入受保护页面会触发异常

### Page Tables Storage

- 页表大小示例：
    - 32位地址，4KiB页面时
    - 单个页表大小：$4 \times 2^{20}$ 字节 = 4MiB
    - 约占4GB内存的0.1%
    - 对缓存来说太大了！

所以，页表存储在内存(DRAM)中。导致的性能影响：

- 在缓存未命中时，每个lw/sw需要两次内存访问
- 使用缓存策略优化：
	- 以块为单位在DRAM和处理器缓存之间传输
	- 利用空间局部性
	- 为常用页表项使用专门的缓存（TLB）

## Page Fault

### Blocks vs. Pages

- 缓存块：通常约64B
- 内存页面：通常约4 KiB
- 内存层次：
```
字节(Bytes) < 字(Words) < 块(Blocks) < 页面(Pages)
```

### Memory Access

检查页表条目的有效位：

- 如果页面有效，检查位置位：
    - 在内存中：直接访问
    - 在磁盘上：需要页面置换
		- 在内存中选择牺牲页面
		- 如果页面被修改，写回磁盘
		- 从磁盘读取所需页面
		- 更新页表
		- 重新执行触发页面错误的指令
- 如果页面无效：
	- 分配新页面
		- 如果内存不足，牺牲一个页面
		- 读/写数据

数据在磁盘上，页面无效或违反访问权限，都会触发页面错误。

- 页面错误作为异常处理
	- 由页面错误处理程序（中断/陷阱处理程序的一部分）处理
	- 更新状态位
- 必要时执行上下文切换
- 错误处理后重新执行指令
