# Pipelining II

*December 6, 2024*

## Pipelining RISC-V

|       Phase       | $t_{step}$ Serial | $t_{cycle}$ Pipelined |
| :---------------: | :---------------: | :-------------------: |
|       指令获取        |      200 ps       |        200 ps         |
|       寄存器读取       |      100 ps       |      ==200 ps==       |
|        ALU        |      200 ps       |        200 ps         |
|       内存写入        |      200 ps       |        200 ps         |
|       寄存器写入       |      100 ps       |      ==200 ps==       |
| $t_{instruction}$ |      800 ps       |      ==1000 ps==      |

“顺序的”（sequential）RISC-V 数据通路：

![[Sequential RISC-V Datapath.png]]

流水线化的 RISC-V 数据通路：

![[Pipelined RISC-V Datapath.png]]

## Pipelining Datapath

[[Lec 19#Single-Cycle RV32I Datapath]]

Pipelined RV32I Datapath: 

![[Pipelined RV32I Datapath.png]]

- 流水线寄存器分离各阶段，为流程中每条指令保存数据
- 在 M 阶段重新计算 PC+4，避免将 PC 和 PC+4 同时发送到流水线中
- 必须将指令与数据一起进行流水线处理，以便控制在每个阶段都能正确运行

流水线化的逻辑控制：
- 控制信号由指令产生
- 类似于单周期的实现
- 每个阶段的信息被存储在流水线寄存器中用于后续的阶段

## Pipeline Hazards

冒险（hazard）是指在下一个时钟周期内无法启动下一条指令的情况

1. 结构性冒险（*Structural*）
	- 所需的源繁忙（例如多个阶段都需要）
2. 数据冒险（*Data*）
	- 指令之间的数据依赖
	-  需要等待前一条指令完成数据读/写
3. 控制冒险（*Control*）
	- 执行流程取决于前一条指令

## Structural Hazard

- 问题：流水线中的两条或更多条指令争相访问单个物理资源
- 解决方法 1：指令轮流使用资源，某些指令不得不暂停运行
- 解决方法 2：为机器添加更多硬件
	- 总是可以通过增加硬件来解决结构性隐患

### Regfile Read and Write

- 每条指令：
	- 在解码阶段最多可读取两个操作数
	- 可在回写阶段写入一个值
- 通过单独的 "端口 "避免结构冒险
	- 两个独立的读端口和一个独立的写端口
- 每个周期可同时进行三次访问

简而言之就是允许一个周期内**同时完成读和写**寄存器文件。

### Memory Access

- 指令内存和数据内存被同时读取
- 通过两个独立的缓存，指令缓存和数据缓存，避免结构性冒险

### Summary

- 物理资源使用冲突
- 在具有单一内存的 RISC-V 流水线中
	- 加载/存储需要访问数据
	- 如果没有单独的内存，指令获取将不得不在该周期内暂停（*stall*）
		- 流水线中的所有其他操作都需要等待
- 流水线数据通路需要单独的指令/数据内存
	- 或单独的指令/数据缓存
- RISC ISA（包括 RISC-V）旨在避免结构性冒险
	- 例如，每条指令最多访问一次内存

## Data Hazards

### Register Access

我们将寄存器文件接口分离来避免结构性冒险，但是如果要在一个周期内读写同一个寄存器呢？解决方法：

- 利用寄存器文件的高速性（100ps）
- 将一个时钟周期平均拆分成两部分
	- 前一部分进行写入
	- 后一部分进行读取
- 在同一周期内写入和读取可能并不总是可行的，尤其是在高频设计中

### ALU Result

- 问题：指令依赖于先前指令的结果（仍未写入寄存器）

#### Solution 1: Stalling

![[stalling.png]]

通过插入”气泡“延后流水线中的后续指令。例如，发现rs为上一条指令lw所读取的，这时候还没读取结束，则控制信号会被置零，想后续的阶段插入气泡，使该命令失效，PC没有更新，在下一个时钟会重新执行该指令。

气泡实际上就像是 `nop` ，让流水线阶段什么都不做。

- 暂停会降低性能。但要获得正确的结果是难免的
- 编译器可以通过调整代码的顺序或插入 `nop` 指令来避免冒险和暂停

#### Solution 2: Forwarding

数据转传：从流水线阶段而不是寄存器文件中获取操作数。

![[data forwarding.png]]

通过新增数据通路使 ALU 的计算结果或从内存的加载的数据，可以传到流水线先前的阶段，作为后续指令 ALU 的操作数，在当前指令完成前直接使用计算结果。

- 无需等待将结果存储到寄存器中
- 数据路径中需要额外连接

![[forwarding.png]]

注意，图中只展示了对 ALU 操作数 A 的转传，同样的对 操作数 B 也需要转传。

### Load Data Hazard

如果当前 `lw` 指令目标寄存器是下一条指令的源寄存器，即下一条指令**使用了加载的结果**，那么在流水线中，加载内存的阶段将与该寄存器参与 ALU 运算的阶段同时发生。数据转传不能超越时间！所以加载需要流水线**暂停一个周期**。

- 加载指令后的槽称为加载延迟槽（*load delay slot*）
	- 如果该指令使用了加载的结果，那么硬件将停滞一个周期
	- 相当于在槽中插入一个显式 nop
	- 造成性能损失
- 解决它的想法：
	- 将无关指令放入加载延迟槽中
	- 重新排列代码，避免在下一个指令中使用加载结果、
	- 没有性能损失！
