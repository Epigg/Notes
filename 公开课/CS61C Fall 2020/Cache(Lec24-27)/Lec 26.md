# Cache III

*December 8, 2024*

## Direct Mapped Example

举个例子，访问直接映射缓存中的数据：

- 首先访问地址的索引字段，找到缓存对应的块
- 检查块的有效位和标签
	-  有效位为0
		- 有效位设为1，设置标签
		- 将下一级中对应位置数据备份到块中
	- 有效位为1但是块的标签与地址的标签字段不同
		- 设置标签
		- 将下一级中对应位置数据备份到块中，代替原数据
- 根据偏移量字段，从缓存中返回数据块（*data chunk*，1,2,4个字节）

 注意：加载字指令时，偏移量字段的后两位应为0

## Writes, Block Sizes, Misses

图中，每个块存储四个字，缓存大小为4k个字

![[Multiword-Block Direct-Mapped Cache.png]]

### Write hit

- 直写（write-through）
	-  同时更新缓存和内存
- 写回（write-back）
	-  仅更新缓存块中的字
	- 允许内存中的字保持"过时"（stale）状态
	- 在块中添加”变脏“标记位（"dirty" bit）
		- 内存和缓存不一致
		- 在替换块时，内存需要更新
	- 操作系统在 I/O 操作前需要刷新缓存

直写优点：

1. 数据一致性好：由于内存和缓存始终保持同步，不会出现数据不一致的问题
2. 实现简单：不需要维护复杂的状态信息，硬件设计相对简单
3. 系统恢复容易：当系统发生故障时，由于内存总是包含最新数据，恢复过程较为简单
4. I/O操作便利：外围设备可以直接从内存读取最新数据，不需要考虑缓存状态

缺点：

1. 写操作性能较差：每次写操作都需要访问主存，增加了系统总线的负载
2. 内存带宽要求高：所有的写操作都必须经过系统总线传输到内存
3. 功耗较大：频繁的内存访问会增加系统的能耗
4. 写入延迟高：每次写操作都需要等待较慢的内存写入完成

相对的，写回的优缺点可见一斑。

### Block Size Tradeoff

块大小较大的优点：

- **空间局部性**：如果访问某个字，很可能很快会访问附近的其他字
- 与存储程序（Stored-Program）概念非常契合
- 对顺序数组访问效果很好

块大小较大的缺点：

- 更大的块大小意味着**更大的未命中惩罚**
	- 未命中时，从下一级加载新块需要更长时间
- 如果块大小相对于缓存大小太大，则块数会太少
	- 导致**未命中率上升**

### Types of Cache Misses

未命中的"三C"模型

第一个C：强制性（Compulsory）未命中

- 程序首次启动时发生
- 缓存尚未包含该程序的任何数据，必然会发生未命中
- 难以避免
- 内存的每个块都会有一次强制性未命中（不仅仅是缓存的每个块）

第二个C：冲突（Conflict）未命中

- 由于两个不同的内存地址映射到相同的缓存位置而发生的未命中
- 两个映射到相同位置的块会不断覆盖彼此
- 在直接映射缓存中是个大问题

如何减少冲突未命中的影响：

- 解决方案1：增大缓存大小
	- 在某些情况会失效，例如**颠簸**（来回读取映射到相同的缓存位置的内存地址）
- 解决方案2：允许多个不同的块放在相同的缓存索引位置（Set Associative）

## Fully Associative Caches

内存地址字段中的**索引不存在**了，只剩下标签和偏移量了。

- 不再有”行“了，每个块都可以在缓存中的任意位置
	- 优点：没有冲突未命中了（因为数据可以放在任何位置）
- 但是必须比较缓存中的所有标签来确定数据是否在缓存中
	- **并行地**（*in parallel*）比较所有标签
	- 缺点：每个条目（*entry*）都需要硬件比较器
		- 如果缓存有64KB数据，每个条目4B，就需要16K个比较器
		- 对硬件来说，这是不可行的

### Final Type of Cache Misses

第三个C：容量（Capacity）未命中

- 由于缓存大小有限而发生的未命中
- 增加缓存大小就不会发生的未命中
- 全相联缓存的主要未命中类型

### Categorize Misses

针对一组不同配置的高速缓存运行地址跟踪：

1. 首先考虑无限大小的全相联缓存，所有未命中都是**强制性未命中**
2. 然后考虑有限大小的全相联缓存，除第1步外的未命中是**容量未命中**
3. 最后考虑有限大小和有限相联度的缓存，除第1、2步外的未命中是**冲突未命中**
