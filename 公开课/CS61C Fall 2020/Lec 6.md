# Floating Point

*November 20, 2024*

### Basics and Fixed Point

N个位至多表示 $2^N$ 个东西，可以是：

- 无符号整数：0 ~ $2^N$ - 1
- 有符号整数：$-2^{N-1}$ ~ $2^{N-1} - 1$ 

考虑二进制非浮点小数，共六位且二进制点(*binary point*，二进制意义下的小数点)固定在第二位整数后，即 `xx.yyyy` ，则可表示的范围是 0 ~ 3.9375

## Floating Point

### Representation

- 标准形式： $1.xx...x_{two} * 2^{yy...y_{two}}$ 
- 内存表示(float, 32位)：
	- Sign: 符号位，1位
	- Exponent: 指数位，表示y，8位
	- Significand: 有效位，表示x，23位

使用浮点表示法，每个数字都带有一个指数字段，记录其二进制点的位置，有效地利用了我们有限的位。二进制点可以在存储位之外，因此可以表示非常大和很小的数字，约 $1.2 * 10^{-38}$ 到 $3.4 * 10^{38}$ 。

- 如果结果更大 → 上溢(*Overflow*) 正指数过大
- 如果结果更小 → 下溢(*Underflow*) 负指数过大

### IEEE 754 Floating Point Stantard

- float: 1 + 8 + 23
- double: 1 + 11 + 52

1. Sign:
	- 1表示负数，0表示正数
2. Exponent: **"biased exponent"**
	- 因为想要更大的二进制数表示更大的浮点数，而负数的补码对应成二进制数是更大的。
	- float采用 -127 作为偏置，$[0, 255] → [-127, 128]$  

最终的表达：$(-1)^{Sign} * (1 + .Significand) * 2^{Exponent - 127}$ 

双精度是完全类似的，只有位数上的不同。

可表示的数并不是均匀分布的，越靠近原点处它们越稠密。

## Special Numbers

### ±∞

对于浮点数，除以0将得到正负无穷，而不是数据溢出，因为对无穷做进一步的运算是可行的。

表示：所有指数位为1，所有有效位为0

### 0

表示：所有指数位为0，所有有效位为0

此时考虑到符号位，+0 和 -0 两个 0 都是可行的。

### NaN(Not a Number)

当指数位为 255 且有效位不为 0 时，此时表示为 NaN。如运算结果不为无穷或实数时，会返回NaN。`NaN != NaN`

### Denorms

发现可表示的浮点数在 0 附近存在差距，最小的是 $2^{-126}$ ，第二小的是 $2^{-126} + 2^{-149}$ ，标准化和隐含的 1 是罪魁祸首。

非规格化表示：指数位为 0，有效位不为 0。这时候表示的数去除了（隐含的）前导的 1，指数为1-bias，可以平滑转换到规格化。

## Discussion

一个例子： $1/3=1.01010101...*2^{-2}=0|0111 1101|0101 0101 0101 0101 0101 010$ 

### Precision and Accuracy

 $x=-1.5*10^{38}, y=1.5*10^{38}, z=1.0$

- $x+(y+z)=-1.5*10^{38}+(1.5*10^{38}+1.0)=-1.5*10^{38}+1.5*10^{38}=0.0$ 
- $(x+y)+z=(-1.5*10^{38}+1.5*10^{38})+1.0=0.0+1.0=1.0$
- 浮点数加法是不满足结合律的
- 浮点数只是真实结果的近似(*approximates*)

精度(*Precision*)是用来表示一个值的位数的计数。准确度(*Accuracy*)是一个值的实际值与其计算机表示之间的差异。高精度可以允许，但是不保证高准确度。

### Rounding

- 当对实数进行数学运算时，必须考虑舍入以使结果符合有效值字段
- 浮点数硬件携带两个额外的精度位，然后舍入得到正确的值
- 将双精度数转换为单精度，或将浮点数转换为整数时也会舍入

IEEE 浮点数舍入模式：

- 向正无穷舍入
- 向负无穷舍入
- 截断尾部（向 0 舍入）
- 向偶数舍入（默认模式）
	- 这样一来，一半的时间我们向上舍入，另一半的时间我们向下舍入。倾向于平衡不准确性，确保计算的公平性

### Addition

- 去规格化以匹配指数位
- 有效位相加，保持指数位不变
	- 如果符号不同，就做减法
- 规格化并舍入，得到结果

### Casting

1. float -> int: 采用截断操作
	- 如需四舍五入，使用 `(int) (x + 0.5)`
2. int -> float -> int: 结果和原始值不总是相同，原因是精度损失
	- int -> double -> int: 是相同的，因为int没有超出double的精度，若使用long long则仍可能与原始值不同

## Other Floating Point Representation

- fp128: 1+15+112 
- fp256: 1+19+ 236
- fp16: 1+5+10
- bfloat16: 1+8+7
- TF32: 1+8+10
- Unum: 可变精度
